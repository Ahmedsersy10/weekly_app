// ignore_for_file: unused_local_variable

import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';
import 'package:flutter/material.dart';
import '../../data/models/task_model.dart';
import '../../data/models/weekly_state_model.dart';
import '../../data/models/recurrence_model.dart';
import '../../data/services/hive_service.dart';
import '../../../../core/models/settings_model.dart';
import '../../../../core/services/settings_service.dart';

part 'weekly_state.dart';

class WeeklyCubit extends Cubit<WeeklyState> {
  WeeklyCubit() : super(const WeeklyInitial()) {
    _initializeWithSampleData();
  }

  final _uuid = const Uuid();
  WeekStart _currentWeekStart = WeekStart.saturday; // Default week start

  void _initializeWithSampleData() async {
    List<TaskModel> tasks = HiveService.loadTasks();

    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();

    if (tasks.isEmpty) {
      tasks = [];
    }

    try {
      final settings = await SettingsService.loadSettings();
      _currentWeekStart = settings.weekStart;


    } catch (e) {
      _currentWeekStart = WeekStart.saturday;
    }

    _updateState(tasks);
  }

  void updateWeekStart(WeekStart weekStart) {
    _currentWeekStart = weekStart;
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      _updateState(currentState.weeklyState.tasks);
    }
  }

  void addTask(
    String title,
    int dayOfWeek, {
    bool isImportant = false,
    TimeOfDay? reminderTime,
    TaskPriority priority = TaskPriority.medium,
    String categoryId = 'other',
    String? description,
    List<String> tags = const [],
    RecurrenceRule? recurrenceRule,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final newTask = TaskModel(
        id: _uuid.v4(),
        title: title,
        description: description,
        isCompleted: false,
        dayOfWeek: dayOfWeek,
        isImportant: isImportant,
        reminderTime: reminderTime,
        priority: priority,
        categoryId: categoryId,
        tags: tags,
        recurrenceRule: recurrenceRule,
      );

      final updatedTasks = List<TaskModel>.from(currentState.weeklyState.tasks)
        ..add(newTask);
      
      // If this is a recurring task, generate instances for the next few weeks
      if (recurrenceRule != null && recurrenceRule.isRecurring) {
        final recurringInstances = _generateRecurringInstances(newTask, recurrenceRule);
        updatedTasks.addAll(recurringInstances);
      }
      
      _updateState(updatedTasks);

    }
  }

  void addQuickTask(String title, int dayOfWeek) {
    addTask(title, dayOfWeek);
  }

  void toggleTaskCompletion(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          return task.copyWith(isCompleted: !task.isCompleted);
        }
        return task;
      }).toList();

      _updateState(updatedTasks);
    }
  }

  void _updateState(List<TaskModel> tasks) {
    final weekNumber = _getCurrentWeekNumber();
    final totalTasks = tasks.length;
    final completedTasks = tasks.where((task) => task.isCompleted).length;
    final completionPercentage = totalTasks > 0
        ? (completedTasks / totalTasks) * 100
        : 0.0;
    final dayStats = _calculateDayStats(tasks);

    final newState = WeeklyStateModel(
      tasks: tasks,
      weekNumber: weekNumber,
      totalTasks: totalTasks,
      completedTasks: completedTasks,
      completionPercentage: completionPercentage,
      dayStats: dayStats,
    );

    HiveService.saveTasks(tasks);

    emit(WeeklySuccess(newState));
  }

  List<TaskModel> getAllTasks() {
    if (state is WeeklySuccess) {
      return (state as WeeklySuccess).weeklyState.tasks;
    }
    return [];
  }

  void toggleDayCollapsed(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final updated = Set<int>.from(current.collapsedDays);
      if (updated.contains(dayOfWeek)) {
        updated.remove(dayOfWeek);
      } else {
        updated.add(dayOfWeek);
      }
      emit(WeeklySuccess(current.copyWith(collapsedDays: updated)));
    }
  }

  bool areAllTasksCompletedForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final dayTasks = current.tasks
          .where((t) => t.dayOfWeek == dayOfWeek)
          .toList();
      if (dayTasks.isEmpty) return false;
      return dayTasks.every((t) => t.isCompleted);
    }
    return false;
  }

  static int _getCurrentWeekNumber() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    final startOfYear = DateTime(today.year, 1, 1);

    final startOfYearWeekday = startOfYear.weekday == 7
        ? 0
        : startOfYear.weekday;

    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;

    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;

    return (daysSinceStart ~/ 7) + 1;
  }

  void testWeekCalculation() {
    final testDates = [
      DateTime(2025, 1, 1), // 1 يناير 2025 (الأربعاء)
      DateTime(2025, 1, 4), // 4 يناير 2025 (السبت)
      DateTime(2025, 8, 16), // 16 أغسطس 2025 (السبت)
    ];

    for (final date in testDates) {
      final weekNum = _getWeekNumberForDate(date);
      print(
        'التاريخ: ${date.day}/${date.month}/${date.year} = الأسبوع $weekNum',
      );
    }
  }

  static int _getWeekNumberForDate(DateTime targetDate) {
    final today = DateTime(targetDate.year, targetDate.month, targetDate.day);

    final startOfYear = DateTime(today.year, 1, 1);
    final startOfYearWeekday = startOfYear.weekday == 7
        ? 0
        : startOfYear.weekday;
    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;
    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;
    return (daysSinceStart ~/ 7) + 1;
  }

  List<DayStats> _calculateDayStats(List<TaskModel> tasks) {
    final weekStart = _currentWeekStart; // Use the current week start
    final dayNames = _getDayNames(weekStart);
    final dayStats = <DayStats>[];

    for (int i = 0; i < 6; i++) {
      final dayTasks = tasks.where((task) => task.dayOfWeek == i).toList();
      final totalTasks = dayTasks.length;
      final completedTasks = dayTasks.where((task) => task.isCompleted).length;
      final date = _getDateForDayIndex(i, weekStart);

      dayStats.add(
        DayStats(
          dayOfWeek: i,
          dayName: dayNames[i],
          totalTasks: totalTasks,
          completedTasks: completedTasks,
          date: date,
        ),
      );
    }

    return dayStats;
  }

  List<String> _getDayNames(WeekStart weekStart) {
    final dayNames = <String>[];

    switch (weekStart) {
      case WeekStart.saturday:
        dayNames.addAll([
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
        ]);
        break;
      case WeekStart.sunday:
        dayNames.addAll([
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
        ]);
        break;
      case WeekStart.monday:
        dayNames.addAll([
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
        ]);
        break;
      case WeekStart.tuesday:
        dayNames.addAll([
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
        ]);
        break;
      case WeekStart.wednesday:
        dayNames.addAll([
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
        ]);
        break;
      case WeekStart.thursday:
        dayNames.addAll([
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
        ]);
        break;
      case WeekStart.friday:
        dayNames.addAll([
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
        ]);
        break;
    }

    return dayNames;
  }

  String _getDateForDayIndex(int dayIndex, WeekStart weekStart) {
    final now = DateTime.now();
    final startOfWeek = _getStartOfWeek(now, weekStart);
    final targetDate = startOfWeek.add(Duration(days: dayIndex));

    final day = targetDate.day.toString().padLeft(2, '0');
    final month = targetDate.month.toString().padLeft(2, '0');

    return '$day/$month';
  }

  DateTime _getStartOfWeek(DateTime date, WeekStart weekStart) {
    final weekday = date.weekday; // Monday = 1, Sunday = 7

    int weekStartDay;
    switch (weekStart) {
      case WeekStart.monday:
        weekStartDay = 1;
        break;
      case WeekStart.tuesday:
        weekStartDay = 2;
        break;
      case WeekStart.wednesday:
        weekStartDay = 3;
        break;
      case WeekStart.thursday:
        weekStartDay = 4;
        break;
      case WeekStart.friday:
        weekStartDay = 5;
        break;
      case WeekStart.saturday:
        weekStartDay = 6;
        break;
      case WeekStart.sunday:
        weekStartDay = 7;
        break;
    }

    int daysToSubtract = weekday - weekStartDay;
    if (daysToSubtract < 0) {
      daysToSubtract += 7;
    }

    return date.subtract(Duration(days: daysToSubtract));
  }

  List<TaskModel> getTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek)
          .toList();
    }
    return [];
  }

  List<TaskModel> getImportantTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && task.isImportant)
          .toList();
    }
    return [];
  }

  List<TaskModel> getOtherTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && !task.isImportant)
          .toList();
    }
    return [];
  }

  Future<void> reloadTasksFromStorage() async {
    List<TaskModel> tasks = HiveService.loadTasks();
    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();
    _updateState(tasks);
  }

  int getOverdueTasksCount() {
    if (state is WeeklySuccess) {
      final tasks = (state as WeeklySuccess).weeklyState.tasks;
      return tasks.where((t) => t.isOverdue).length;
    }
    return 0;
  }

  int getCurrentStreak() {
    if (state is! WeeklySuccess) return 0;
    final tasks = (state as WeeklySuccess).weeklyState.tasks;
    if (tasks.isEmpty) return 0;

    final today = DateTime.now();
    int streak = 0;

    for (int i = 0; i < 30; i++) {
      final checkDate = today.subtract(Duration(days: i));
      final appDayIndex = _mapDateTimeToAppDayIndex(checkDate);
      if (appDayIndex == null) {
        streak++;
        continue;
      }
      final dayTasks = tasks.where((t) => t.dayOfWeek == appDayIndex).toList();
      if (dayTasks.isEmpty) {
        streak++;
      } else if (dayTasks.every((t) => t.isCompleted)) {
        streak++;
      } else {
        break;
      }
    }

    return streak;
  }

  int? _mapDateTimeToAppDayIndex(DateTime date) {
    switch (date.weekday) {
      case DateTime.saturday:
        return 0;
      case DateTime.sunday:
        return 1;
      case DateTime.monday:
        return 2;
      case DateTime.tuesday:
        return 3;
      case DateTime.wednesday:
        return 4;
      case DateTime.thursday:
        return 5;
      case DateTime.friday:
        return null; // Day off in app model
      default:
        return null;
    }
  }

  bool _isAutoGeneratedTask(TaskModel task) {
    final autoGeneratedTitles = [];
    return autoGeneratedTitles.contains(task.title);
  }

  void editTask(
    String taskId,
    String newTitle, {
    bool? isImportant,
    TimeOfDay? reminderTime,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      TaskModel? originalTask;

      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          originalTask = task;
          return task.copyWith(
            title: newTitle,
            isImportant: isImportant ?? task.isImportant,
            reminderTime: reminderTime,
          );
        }
        return task;
      }).toList();

      _updateState(updatedTasks);

    }
  }

  void deleteTask(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.id != taskId)
          .toList();

      _updateState(updatedTasks);

    }
  }

  void clearTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      final tasksToClear = currentState.weeklyState.tasks.where(
        (task) => task.dayOfWeek == dayOfWeek,
      );

      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek != dayOfWeek)
          .toList();

      _updateState(updatedTasks);
    }
  }

  void clearAllTasks() {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;


      _updateState([]);
    }
  }

  /// Generate recurring task instances for the next few weeks/months
  List<TaskModel> _generateRecurringInstances(TaskModel parentTask, RecurrenceRule recurrenceRule) {
    final instances = <TaskModel>[];
    final now = DateTime.now();
    final endDate = now.add(const Duration(days: 90)); // Generate for next 3 months
    
    final occurrences = recurrenceRule.generateOccurrences(now, endDate);
    
    for (final occurrence in occurrences) {
      // Skip the original task date
      if (occurrence.isAtSameMomentAs(now)) continue;
      
      final dayIndex = _mapDateTimeToAppDayIndex(occurrence);
      if (dayIndex == null) continue; // Skip Friday (day off)
      
      final instance = parentTask.copyWith(
        id: _uuid.v4(),
        parentRecurrenceId: parentTask.id,
        dayOfWeek: dayIndex,
        createdAt: occurrence,
        isCompleted: false,
        completedAt: null,
      );
      
      instances.add(instance);
    }
    
    return instances;
  }

  /// Delete a recurring task series or single instance
  void deleteRecurringTask(String taskId, {bool deleteEntireSeries = false}) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);
      
      List<TaskModel> updatedTasks;
      
      if (deleteEntireSeries || task.isRecurrenceParent) {
        // Delete the entire series
        final seriesId = task.isRecurrenceParent ? task.id : task.parentRecurrenceId;
        updatedTasks = currentState.weeklyState.tasks
            .where((t) => t.id != seriesId && t.parentRecurrenceId != seriesId)
            .toList();
      } else {
        // Delete only this instance
        updatedTasks = currentState.weeklyState.tasks
            .where((t) => t.id != taskId)
            .toList();
      }
      
      _updateState(updatedTasks);
    }
  }

  /// Edit a recurring task series or single instance
  void editRecurringTask(
    String taskId,
    String newTitle, {
    bool? isImportant,
    TimeOfDay? reminderTime,
    TaskPriority? priority,
    String? categoryId,
    bool editEntireSeries = false,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);
      
      List<TaskModel> updatedTasks;
      
      if (editEntireSeries || task.isRecurrenceParent) {
        // Edit the entire series
        final seriesId = task.isRecurrenceParent ? task.id : task.parentRecurrenceId;
        updatedTasks = currentState.weeklyState.tasks.map((t) {
          if (t.id == seriesId || t.parentRecurrenceId == seriesId) {
            return t.copyWith(
              title: newTitle,
              isImportant: isImportant ?? t.isImportant,
              reminderTime: reminderTime,
              priority: priority ?? t.priority,
              categoryId: categoryId ?? t.categoryId,
            );
          }
          return t;
        }).toList();
      } else {
        // Edit only this instance - break it from the series
        updatedTasks = currentState.weeklyState.tasks.map((t) {
          if (t.id == taskId) {
            return t.copyWith(
              title: newTitle,
              isImportant: isImportant ?? t.isImportant,
              reminderTime: reminderTime,
              priority: priority ?? t.priority,
              categoryId: categoryId ?? t.categoryId,
              parentRecurrenceId: null, // Break from series
              recurrenceRule: null,
            );
          }
          return t;
        }).toList();
      }
      
      _updateState(updatedTasks);
    }
  }

  /// Get all tasks in a recurring series
  List<TaskModel> getRecurringSeries(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final task = currentState.weeklyState.tasks.firstWhere((t) => t.id == taskId);
      
      if (task.isRecurrenceParent) {
        return currentState.weeklyState.tasks
            .where((t) => t.id == taskId || t.parentRecurrenceId == taskId)
            .toList();
      } else if (task.isRecurrenceInstance) {
        return currentState.weeklyState.tasks
            .where((t) => t.parentRecurrenceId == task.parentRecurrenceId || t.id == task.parentRecurrenceId)
            .toList();
      }
    }
    return [];
  }

  @override
  Future<void> close() async {
    await HiveService.close();
    super.close();
  }
}
