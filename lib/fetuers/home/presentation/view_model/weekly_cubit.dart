import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';
import 'package:uuid/uuid.dart';
import 'package:flutter/material.dart';
import '../../data/models/task_model.dart';
import '../../data/models/weekly_state_model.dart';
import '../../data/services/hive_service.dart';
import '../../../../core/models/settings_model.dart';
import '../../../../core/services/settings_service.dart';

part 'weekly_state.dart';

class WeeklyCubit extends Cubit<WeeklyState> {
  WeeklyCubit() : super(const WeeklyInitial()) {
    _initializeWithSampleData();
  }

  final _uuid = const Uuid();
  WeekStart _currentWeekStart = WeekStart.saturday; // Default week start

  void _initializeWithSampleData() async {
    // Try to load saved tasks first
    List<TaskModel> tasks = HiveService.loadTasks();

    // Filter out auto-generated tasks (system placeholder tasks)
    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();

    // If no saved tasks, use sample data
    if (tasks.isEmpty) {
      tasks = [];
    }

    // Load initial week start from settings
    try {
      final settings = await SettingsService.loadSettings();
      _currentWeekStart = settings.weekStart;

      // Restore notifications after app restart if enabled
      // if (settings.notificationsEnabled) {
      //   final tasksWithReminders = tasks
      //       .where((task) => task.reminderTime != null)
      //       .map(
      //         (task) => {
      //           'id': task.id,
      //           'dayOfWeek': task.dayOfWeek,
      //           'reminderTime': task.reminderTime!,
      //           'title': task.title,
      //         },
      //       )
      //       .toList();

      //   await NotificationService.restoreNotificationsAfterRestart(
      //     reminderTimes: settings.reminderTimes,
      //     tasksWithReminders: tasksWithReminders,
      //   );
      // }
    } catch (e) {
      // Use default if settings loading fails
      _currentWeekStart = WeekStart.saturday;
    }

    _updateState(tasks);
  }

  void updateWeekStart(WeekStart weekStart) {
    _currentWeekStart = weekStart;
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      _updateState(currentState.weeklyState.tasks);
    }
  }

  void addTask(
    String title,
    int dayOfWeek, {
    bool isImportant = false,
    TimeOfDay? reminderTime,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final newTask = TaskModel(
        id: _uuid.v4(),
        title: title,
        isCompleted: false,
        dayOfWeek: dayOfWeek,
        isImportant: isImportant,
        reminderTime: reminderTime,
      );

      final updatedTasks = List<TaskModel>.from(currentState.weeklyState.tasks)
        ..add(newTask);
      _updateState(updatedTasks);

      // Schedule notification if reminder time is set
      // if (reminderTime != null) {
      //   NotificationService.scheduleTaskNotification(
      //     taskId: newTask.id,
      //     dayOfWeek: dayOfWeek,
      //     time: reminderTime,
      //     taskTitle: title,
      //   );
      // }
    }
  }

  void toggleTaskCompletion(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          return task.copyWith(isCompleted: !task.isCompleted);
        }
        return task;
      }).toList();

      _updateState(updatedTasks);
    }
  }

  void _updateState(List<TaskModel> tasks) {
    final weekNumber = _getCurrentWeekNumber();
    final totalTasks = tasks.length;
    final completedTasks = tasks.where((task) => task.isCompleted).length;
    final completionPercentage = totalTasks > 0
        ? (completedTasks / totalTasks) * 100
        : 0.0;
    final dayStats = _calculateDayStats(tasks);

    final newState = WeeklyStateModel(
      tasks: tasks,
      weekNumber: weekNumber,
      totalTasks: totalTasks,
      completedTasks: completedTasks,
      completionPercentage: completionPercentage,
      dayStats: dayStats,
    );

    // Save tasks to local storage
    HiveService.saveTasks(tasks);

    emit(WeeklySuccess(newState));
  }

  List<TaskModel> getAllTasks() {
    if (state is WeeklySuccess) {
      return (state as WeeklySuccess).weeklyState.tasks;
    }
    return [];
  }

  void toggleDayCollapsed(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final updated = Set<int>.from(current.collapsedDays);
      if (updated.contains(dayOfWeek)) {
        updated.remove(dayOfWeek);
      } else {
        updated.add(dayOfWeek);
      }
      emit(WeeklySuccess(current.copyWith(collapsedDays: updated)));
    }
  }

  bool areAllTasksCompletedForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final current = (state as WeeklySuccess).weeklyState;
      final dayTasks = current.tasks
          .where((t) => t.dayOfWeek == dayOfWeek)
          .toList();
      if (dayTasks.isEmpty) return false;
      return dayTasks.every((t) => t.isCompleted);
    }
    return false;
  }

  static int _getCurrentWeekNumber() {
    final now = DateTime.now();
    final today = DateTime(now.year, now.month, now.day);

    // بداية السنة
    final startOfYear = DateTime(today.year, 1, 1);

    // حساب يوم الأسبوع: السبت = 6, الأحد = 0, الاثنين = 1, ... الجمعة = 5
    final startOfYearWeekday = startOfYear.weekday == 7
        ? 0
        : startOfYear.weekday;

    // نحسب كام يوم نرجع عشان نوصل لأقرب سبت قبل أو عند 1 يناير
    // لو 1 يناير = سبت (0) → ما نرجعش حاجة (0 أيام)
    // لو 1 يناير = أحد (1) → نرجع يوم واحد
    // لو 1 يناير = أربعاء (3) → نرجع 4 أيام
    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;

    // أول سبت في السنة أو قبلها
    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    // بداية الأسبوع الحالي (السبت)
    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    // الفرق بالأيام
    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;

    // رقم الأسبوع
    return (daysSinceStart ~/ 7) + 1;
  }

  // دالة للاختبار
  void testWeekCalculation() {
    // اختبار على تواريخ مختلفة
    final testDates = [
      DateTime(2025, 1, 1), // 1 يناير 2025 (الأربعاء)
      DateTime(2025, 1, 4), // 4 يناير 2025 (السبت)
      DateTime(2025, 8, 16), // 16 أغسطس 2025 (السبت)
    ];

    for (final date in testDates) {
      final weekNum = _getWeekNumberForDate(date);
      print(
        'التاريخ: ${date.day}/${date.month}/${date.year} = الأسبوع $weekNum',
      );
    }
  }

  // دالة مساعدة لحساب رقم الأسبوع لتاريخ معين
  static int _getWeekNumberForDate(DateTime targetDate) {
    final today = DateTime(targetDate.year, targetDate.month, targetDate.day);

    final startOfYear = DateTime(today.year, 1, 1);
    final startOfYearWeekday = startOfYear.weekday == 7
        ? 0
        : startOfYear.weekday;
    final daysToSubtract = startOfYearWeekday == 0 ? 0 : 7 - startOfYearWeekday;
    final firstWeekStart = startOfYear.subtract(Duration(days: daysToSubtract));

    final todayWeekday = today.weekday == 7 ? 0 : today.weekday;
    final startOfCurrentWeek = today.subtract(Duration(days: todayWeekday));

    final daysSinceStart = startOfCurrentWeek.difference(firstWeekStart).inDays;
    return (daysSinceStart ~/ 7) + 1;
  }

  List<DayStats> _calculateDayStats(List<TaskModel> tasks) {
    // Get week start from settings (default to Saturday if not available)
    final weekStart = _currentWeekStart; // Use the current week start
    final dayNames = _getDayNames(weekStart);
    final dayStats = <DayStats>[];

    for (int i = 0; i < 6; i++) {
      final dayTasks = tasks.where((task) => task.dayOfWeek == i).toList();
      final totalTasks = dayTasks.length;
      final completedTasks = dayTasks.where((task) => task.isCompleted).length;
      final date = _getDateForDayIndex(i, weekStart);

      dayStats.add(
        DayStats(
          dayOfWeek: i,
          dayName: dayNames[i],
          totalTasks: totalTasks,
          completedTasks: completedTasks,
          date: date,
        ),
      );
    }

    return dayStats;
  }

  List<String> _getDayNames(WeekStart weekStart) {
    final dayNames = <String>[];

    switch (weekStart) {
      case WeekStart.saturday:
        dayNames.addAll([
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
        ]);
        break;
      case WeekStart.sunday:
        dayNames.addAll([
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
        ]);
        break;
      case WeekStart.monday:
        dayNames.addAll([
          'monday',
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
        ]);
        break;
      case WeekStart.tuesday:
        dayNames.addAll([
          'tuesday',
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
        ]);
        break;
      case WeekStart.wednesday:
        dayNames.addAll([
          'wednesday',
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
        ]);
        break;
      case WeekStart.thursday:
        dayNames.addAll([
          'thursday',
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
        ]);
        break;
      case WeekStart.friday:
        dayNames.addAll([
          'friday',
          'saturday',
          'sunday',
          'monday',
          'tuesday',
          'wednesday',
        ]);
        break;
    }

    return dayNames;
  }

  String _getDateForDayIndex(int dayIndex, WeekStart weekStart) {
    final now = DateTime.now();
    final startOfWeek = _getStartOfWeek(now, weekStart);
    final targetDate = startOfWeek.add(Duration(days: dayIndex));

    // Format as DD/MM
    final day = targetDate.day.toString().padLeft(2, '0');
    final month = targetDate.month.toString().padLeft(2, '0');

    return '$day/$month';
  }

  DateTime _getStartOfWeek(DateTime date, WeekStart weekStart) {
    final weekday = date.weekday; // Monday = 1, Sunday = 7

    // Convert WeekStart enum to weekday number
    int weekStartDay;
    switch (weekStart) {
      case WeekStart.monday:
        weekStartDay = 1;
        break;
      case WeekStart.tuesday:
        weekStartDay = 2;
        break;
      case WeekStart.wednesday:
        weekStartDay = 3;
        break;
      case WeekStart.thursday:
        weekStartDay = 4;
        break;
      case WeekStart.friday:
        weekStartDay = 5;
        break;
      case WeekStart.saturday:
        weekStartDay = 6;
        break;
      case WeekStart.sunday:
        weekStartDay = 7;
        break;
    }

    // Calculate days to subtract to get to the start of the week
    int daysToSubtract = weekday - weekStartDay;
    if (daysToSubtract < 0) {
      daysToSubtract += 7;
    }

    return date.subtract(Duration(days: daysToSubtract));
  }

  List<TaskModel> getTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek)
          .toList();
    }
    return [];
  }

  List<TaskModel> getImportantTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && task.isImportant)
          .toList();
    }
    return [];
  }

  List<TaskModel> getOtherTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      return currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek == dayOfWeek && !task.isImportant)
          .toList();
    }
    return [];
  }

  Future<void> reloadTasksFromStorage() async {
    List<TaskModel> tasks = HiveService.loadTasks();
    tasks = tasks.where((task) => !_isAutoGeneratedTask(task)).toList();
    _updateState(tasks);
  }

  int getOverdueTasksCount() {
    if (state is WeeklySuccess) {
      final tasks = (state as WeeklySuccess).weeklyState.tasks;
      return tasks.where((t) => t.isOverdue).length;
    }
    return 0;
  }

  int getCurrentStreak() {
    if (state is! WeeklySuccess) return 0;
    final tasks = (state as WeeklySuccess).weeklyState.tasks;
    if (tasks.isEmpty) return 0;

    final today = DateTime.now();
    int streak = 0;

    // Count consecutive days backwards where all tasks for that day are completed (if any exist)
    for (int i = 0; i < 30; i++) {
      final checkDate = today.subtract(Duration(days: i));
      final appDayIndex = _mapDateTimeToAppDayIndex(checkDate);
      if (appDayIndex == null) {
        // If day off in the app model, continue streak
        streak++;
        continue;
      }
      final dayTasks = tasks.where((t) => t.dayOfWeek == appDayIndex).toList();
      if (dayTasks.isEmpty) {
        // No tasks scheduled that day; treat as neutral and continue
        streak++;
      } else if (dayTasks.every((t) => t.isCompleted)) {
        streak++;
      } else {
        break;
      }
    }

    return streak;
  }

  int? _mapDateTimeToAppDayIndex(DateTime date) {
    switch (date.weekday) {
      case DateTime.saturday:
        return 0;
      case DateTime.sunday:
        return 1;
      case DateTime.monday:
        return 2;
      case DateTime.tuesday:
        return 3;
      case DateTime.wednesday:
        return 4;
      case DateTime.thursday:
        return 5;
      case DateTime.friday:
        return null; // Day off in app model
      default:
        return null;
    }
  }

  bool _isAutoGeneratedTask(TaskModel task) {
    // Check if task is auto-generated by looking for specific patterns
    final autoGeneratedTitles = [];
    return autoGeneratedTitles.contains(task.title);
  }

  void editTask(
    String taskId,
    String newTitle, {
    bool? isImportant,
    TimeOfDay? reminderTime,
  }) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      TaskModel? originalTask;

      final updatedTasks = currentState.weeklyState.tasks.map((task) {
        if (task.id == taskId) {
          originalTask = task;
          return task.copyWith(
            title: newTitle,
            isImportant: isImportant ?? task.isImportant,
            reminderTime: reminderTime,
          );
        }
        return task;
      }).toList();

      _updateState(updatedTasks);

      // Update notification if reminder time changed
      // if (originalTask != null) {
      //   final newReminderTime = reminderTime ?? originalTask!.reminderTime;
      //   // NotificationService.updateTaskNotification(
      //   //   taskId: taskId,
      //   //   dayOfWeek: originalTask!.dayOfWeek,
      //   //   time: newReminderTime,
      //   //   taskTitle: newTitle,
      //   // );
      // }
    }
  }

  void deleteTask(String taskId) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;
      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.id != taskId)
          .toList();

      _updateState(updatedTasks);

      // Cancel notification for deleted task
      // NotificationService.cancelTaskNotification(taskId);
    }
  }

  void clearTasksForDay(int dayOfWeek) {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      // Cancel notifications for tasks being cleared
      final tasksToClear = currentState.weeklyState.tasks.where(
        (task) => task.dayOfWeek == dayOfWeek,
      );
      // for (final task in tasksToClear) {
      //   NotificationService.cancelTaskNotification(task.id);
      // }

      final updatedTasks = currentState.weeklyState.tasks
          .where((task) => task.dayOfWeek != dayOfWeek)
          .toList();

      _updateState(updatedTasks);
    }
  }

  void clearAllTasks() {
    if (state is WeeklySuccess) {
      final currentState = state as WeeklySuccess;

      // Cancel all task notifications
      // for (final task in currentState.weeklyState.tasks) {
      //   NotificationService.cancelTaskNotification(task.id);
      // }

      _updateState([]);
    }
  }

  @override
  Future<void> close() async {
    await HiveService.close();
    super.close();
  }
}
